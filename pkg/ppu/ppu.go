package ppu

import (
	"image/color"
)

const (
	PPU_PATTERN_TABLE0   = 0x0000
	PPU_PATTERN_TABLE1   = 0x1000
	PPU_NAME_TABLE0      = 0x2000
	PPU_ATTR_TABLE0      = 0x23C0
	PPU_NAME_TABLE1      = 0x2400
	PPU_ATTR_TABLE1      = 0x27C0
	PPU_NAME_TABLE2      = 0x2800
	PPU_ATTR_TABLE2      = 0x2BC0
	PPU_NAME_TABLE3      = 0x2C00
	PPU_ATTR_TABLE3      = 0x2FC0
	PPU_MIRROR_NE_TABLES = 0x3000
	PPU_BG_PALLET        = 0x3F00
	PPU_SPRITE_PALLET    = 0x3F10
	PPU_MIRROR_PALLETS   = 0x3F20
)

var colors = []color.RGBA{
	{0x80, 0x80, 0x80, 0xFF}, {0x00, 0x3D, 0xA6, 0xFF}, {0x00, 0x12, 0xB0, 0xFF}, {0x44, 0x00, 0x96, 0xFF},
	{0xA1, 0x00, 0x5E, 0xFF}, {0xC7, 0x00, 0x28, 0xFF}, {0xBA, 0x06, 0x00, 0xFF}, {0x8C, 0x17, 0x00, 0xFF},
	{0x5C, 0x2F, 0x00, 0xFF}, {0x10, 0x45, 0x00, 0xFF}, {0x05, 0x4A, 0x00, 0xFF}, {0x00, 0x47, 0x2E, 0xFF},
	{0x00, 0x41, 0x66, 0xFF}, {0x00, 0x00, 0x00, 0xFF}, {0x05, 0x05, 0x05, 0xFF}, {0x05, 0x05, 0x05, 0xFF},
	{0xC7, 0xC7, 0xC7, 0xFF}, {0x00, 0x77, 0xFF, 0xFF}, {0x21, 0x55, 0xFF, 0xFF}, {0x82, 0x37, 0xFA, 0xFF},
	{0xEB, 0x2F, 0xB5, 0xFF}, {0xFF, 0x29, 0x50, 0xFF}, {0xFF, 0x22, 0x00, 0xFF}, {0xD6, 0x32, 0x00, 0xFF},
	{0xC4, 0x62, 0x00, 0xFF}, {0x35, 0x80, 0x00, 0xFF}, {0x05, 0x8F, 0x00, 0xFF}, {0x00, 0x8A, 0x55, 0xFF},
	{0x00, 0x99, 0xCC, 0xFF}, {0x21, 0x21, 0x21, 0xFF}, {0x09, 0x09, 0x09, 0xFF}, {0x09, 0x09, 0x09, 0xFF},
	{0xFF, 0xFF, 0xFF, 0xFF}, {0x0F, 0xD7, 0xFF, 0xFF}, {0x69, 0xA2, 0xFF, 0xFF}, {0xD4, 0x80, 0xFF, 0xFF},
	{0xFF, 0x45, 0xF3, 0xFF}, {0xFF, 0x61, 0x8B, 0xFF}, {0xFF, 0x88, 0x33, 0xFF}, {0xFF, 0x9C, 0x12, 0xFF},
	{0xFA, 0xBC, 0x20, 0xFF}, {0x9F, 0xE3, 0x0E, 0xFF}, {0x2B, 0xF0, 0x35, 0xFF}, {0x0C, 0xF0, 0xA4, 0xFF},
	{0x05, 0xFB, 0xFF, 0xFF}, {0x5E, 0x5E, 0x5E, 0xFF}, {0x0D, 0x0D, 0x0D, 0xFF}, {0x0D, 0x0D, 0x0D, 0xFF},
	{0xFF, 0xFF, 0xFF, 0xFF}, {0xA6, 0xFC, 0xFF, 0xFF}, {0xB3, 0xEC, 0xFF, 0xFF}, {0xDA, 0xAB, 0xEB, 0xFF},
	{0xFF, 0xA8, 0xF9, 0xFF}, {0xFF, 0xAB, 0xB3, 0xFF}, {0xFF, 0xD2, 0xB0, 0xFF}, {0xFF, 0xEF, 0xA6, 0xFF},
	{0xFF, 0xF7, 0x9C, 0xFF}, {0xD7, 0xE8, 0x95, 0xFF}, {0xA6, 0xED, 0xAF, 0xFF}, {0xA2, 0xF2, 0xDA, 0xFF},
	{0x99, 0xFF, 0xFC, 0xFF}, {0xDD, 0xDD, 0xDD, 0xFF}, {0x11, 0x11, 0x11, 0xFF}, {0x11, 0x11, 0x11, 0xFF},
}

type BackgroundContent struct {
	Tile      [][]byte
	PaletteID int
}

type PPU struct {
	Registers     []byte // 0x2000~0x2007
	MemoryMap     [0x3FFF]byte
	Cycle         int
	Line          int
	charROM       []byte
	Background    []BackgroundContent
	addressBuffer []byte
}

func NewPPU(charROM []byte) *PPU {
	return &PPU{
		MemoryMap:     [0x3fff]byte{},
		Cycle:         0,
		Line:          0,
		charROM:       charROM,
		Background:    make([]BackgroundContent, 30),
		addressBuffer: make([]byte, 0, 2),
	}
}

func (p *PPU) Run(cycle int) bool {
	p.Cycle += cycle
	if p.Line == 0 {
		p.Background = p.Background[:0]
	}

	if p.Cycle >= 341 {
		p.Cycle -= 341
		p.Line++

		if p.Line <= 240 && p.Line%8 == 0 {
			p.buildBackground()
		}
		if p.Line == 262 {
			p.Line = 0
			return true
		}
	}
	return false
}

// タイルの座標からどのスプライトを表示すれば良いか判断する
func (p *PPU) getSpriteID(tileX, tileY uint16) byte {
	// TODO: 現状ではname table 0 だけ対応
	return p.MemoryMap[PPU_NAME_TABLE0+tileY*32+tileX]
}

/*  _ _
 * |0|1|
 * |_|_|
 * |2|3|
 * |_|_|
 */

// どのブロックに属しているかを判定している
func (p *PPU) getBlockID(tileX, tileY uint16) byte {
	return (byte(tileX%4) / 2) + (byte(tileY%4)/2)*2
}

func (p *PPU) buildSprite(spriteNum int) [][]byte {
	sprite := make([][]byte, 8)
	for i := 0; i < 8; i++ {
		sprite[i] = make([]byte, 8)
	}

	for i := 0; i < 16; i++ {
		for j := 0; j < 8; j++ {
			if p.charROM[spriteNum*16+i]&(0x80>>j) != 0 {
				sprite[i%8][j] += 0x01 << (i / 8)
			}
		}
	}
	return sprite
}

func (p *PPU) getAttr(tileX, tileY uint16) byte {
	address := PPU_ATTR_TABLE0 + tileX/4 + (tileY/4)*8
	return p.MemoryMap[address]
}

func (p *PPU) buildTile(tileX, tileY uint16) ([][]byte, int) {
	blockID := p.getBlockID(tileX, tileY)
	spriteID := p.getSpriteID(tileX, tileY)
	attr := p.getAttr(tileX, tileY)
	paletteID := (attr >> (blockID * 2)) & 0x03
	sprite := p.buildSprite(int(spriteID))
	return sprite, int(paletteID)
}

func (p *PPU) buildBackground() {
	tileY := (p.Line / 8) % 30
	for x := 0; x < 32; x++ {
		tileX := x % 32
		tile, palette := p.buildTile(uint16(tileX), uint16(tileY))
		p.Background = append(p.Background, BackgroundContent{
			Tile:      tile,
			PaletteID: palette,
		})
	}
}

func (p *PPU) setAddress(addr uint16) {
	p.addressBuffer[0] = byte(addr >> 8)
	p.addressBuffer[1] = byte(addr)
}

func (p *PPU) getAddress() uint16 {
	return uint16(p.addressBuffer[0])<<8 | uint16(p.addressBuffer[1])
}

func (p *PPU) GetData() byte {
	v := p.MemoryMap[p.getAddress()]
	p.setAddress(p.getAddress() + 1)
	return v
}

func (p *PPU) SetData(val byte) {
	p.MemoryMap[p.getAddress()] = val
	p.setAddress(p.getAddress() + 1)
}

func (p *PPU) SetAddress(addr byte) {
	if len(p.addressBuffer) >= 2 {
		p.addressBuffer = p.addressBuffer[:0]
	}
	p.addressBuffer = append(p.addressBuffer, addr)
}
